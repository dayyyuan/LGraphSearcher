package edu.psu.chemxseer.structure.preprocess;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Stack;

import de.parmol.graph.Graph;
import de.parmol.graph.MutableGraph;

/**
 * In charge of parsing & converting the malware graphs
 * 
 * @author dayuyuan
 * 
 */
public class MalwareParser {
	/**
	 * Convert the graphs stored under the base folder to DFS format & serialize
	 * to the datafile
	 * 
	 * @param baseFolder
	 * @throws IOException
	 */
	public static void convertFormat(String baseFolder, String dbFile)
			throws IOException {
		int gID = 0;
		List<Graph> graphs = new ArrayList<Graph>();
		Map<String, Integer> nodeLabels = new HashMap<String, Integer>();
		// depth first search
		Stack<File> files = new Stack<File>();
		File firstElement = new File(baseFolder);
		files.push(firstElement);

		while (!files.isEmpty()) {
			File aFile = files.pop();
			if (aFile.isDirectory()) {
				File[] newFiles = aFile.listFiles();
				for (File newFile : newFiles) {
					if (newFile.isHidden())
						continue;
					else {
						files.push(newFile);
					}
				}
			} else if (aFile.getName().endsWith("sdg")) {
				List<Graph> gs = parser(aFile.getAbsolutePath(), new Integer(
						gID).toString(), nodeLabels);
				if (gs == null)
					continue;
				else
					graphs.addAll(gs);
			} else
				continue;
		}
		// write the graphs to dbFile & dbFile_Meta
		Graph[] dbGraphs = new Graph[graphs.size()];
		graphs.toArray(dbGraphs);
		RandomChoseDBGraph.saveGDB(dbGraphs, MyFactory.getUnCanDFS(), dbFile);
		System.out.println("Distinct Nodes: " + nodeLabels.size());
	}

	/**
	 * Parser & Return a malware Graph Each File Contains one connected
	 * component of the malware
	 * 
	 * @param fileName
	 * @param labels
	 * @return
	 * @throws IOException
	 */
	public static List<Graph> parser(String fileName, String gID,
			Map<String, Integer> labels) throws IOException {
		BufferedReader reader = new BufferedReader(new FileReader(fileName));
		reader.readLine(); // skip the first line of the file
		String nodeCountLine = reader.readLine();
		String[] nodeCountToken = nodeCountLine.split(" ");
		if (nodeCountToken == null || nodeCountToken.length < 2)
			System.out.println("Exception in Reading the number of nodes");
		int nodeCount = Integer.parseInt(nodeCountToken[1]);
		reader.readLine(); // skip the blank line after the node count line
		reader.readLine(); // skip the head line for the node line

		// if(nodeCount > 1000){
		// System.out.println(nodeCount);
		// reader.close();
		// return null;
		// }
		List<Graph> graphs = new ArrayList<Graph>();
		int[] nodes = new int[nodeCount];
		for (int i = 0; i < nodeCount; i++) {
			String aLine = reader.readLine();
			String[] token = aLine.split(" ");
			// int nodeID = Integer.parseInt(token[1]);
			String nodeLabel = token[2];
			int nodeLabelID = labels.size();
			if (labels.containsKey(nodeLabel))
				nodeLabelID = labels.get(nodeLabel);
			else
				labels.put(nodeLabel, nodeLabelID);
			nodes[i] = nodeLabelID;
		}

		reader.readLine(); // skip the blank line after the node line
		reader.readLine(); // skip the head line for the edge line

		@SuppressWarnings("unchecked")
		List<Integer>[] edges = new ArrayList[nodeCount];
		while (true) {
			String aLine = reader.readLine();
			if (aLine == null)
				break;
			String[] token = aLine.split(" ")[1].split(",");
			int fromNodeID = Integer.parseInt(token[0].split(":")[0]);
			int toNodeID = Integer.parseInt(token[1].split(":")[0]);
			if (edges[fromNodeID] == null) {
				edges[fromNodeID] = new ArrayList<Integer>();
				edges[fromNodeID].add(toNodeID);
			} else if (!edges[fromNodeID].contains(toNodeID)) {
				edges[fromNodeID].add(toNodeID);
			}

			if (edges[toNodeID] == null) {
				edges[toNodeID] = new ArrayList<Integer>();
				edges[toNodeID].add(fromNodeID);
			} else if (!edges[toNodeID].contains(fromNodeID)) {
				edges[toNodeID].add(fromNodeID);
			}
		}

		Map<Integer, Integer> OriToNodeID = new HashMap<Integer, Integer>();
		int coveredNodeCount = 0;
		while (coveredNodeCount < nodeCount) {
			// 1. Find the first uncovered node & insert into the
			int firstNode = 0;
			for (int nodeLabel : nodes)
				if (nodeLabel != -1)
					break;
				else
					firstNode++;
			Queue<Integer> candidates = new LinkedList<Integer>();
			MutableGraph g = MyFactory.getGraphFactory().createGraph(
					gID + "_" + graphs.size());
			// 2. Breath first search
			OriToNodeID.clear();
			candidates.add(firstNode);
			while (!candidates.isEmpty()) {
				int node = candidates.poll();
				// insert node
				int nodeNew = -1;
				if (nodes[node] >= 0) {
					nodeNew = g.addNode(nodes[node]);
					OriToNodeID.put(node, nodeNew);
					nodes[node] = -1; // mark as covered
				} else
					nodeNew = OriToNodeID.get(node);

				// insert edges
				List<Integer> adjNodes = edges[node];
				if (adjNodes == null)
					continue;
				for (Integer adjNode : adjNodes) {
					int adjNodeNew = -1;
					if (nodes[adjNode] == -1) {
						adjNodeNew = OriToNodeID.get(adjNode);
						if (g.getEdge(nodeNew, adjNodeNew) == -1)
							g.addEdge(nodeNew, adjNodeNew, 1);
					} else {
						// insert node & edge
						adjNodeNew = g.addNodeAndEdge(nodeNew, nodes[adjNode],
								1);
						nodes[adjNode] = -1;
						OriToNodeID.put(adjNode, adjNodeNew);
						candidates.add(adjNode);
					}
				}
			}
			g.saveMemory();
			coveredNodeCount += g.getNodeCount();
			if (g.getNodeCount() < 10)
				continue;
			else if (g.getNodeCount() < 1000) {
				graphs.add(g);
				// System.out.println(g.getNodeCount() + " " + g.getEdgeCount()
				// + " " + GraphConnectivityTester.isConnected(g));
			}
			// else System.out.println(g.getNodeCount() + " " +
			// g.getEdgeCount());
		}
		reader.close();
		return graphs;
	}

	public static void main(String[] args) throws IOException {
		// test & build
		String baseFolderName = "/Users/dayuyuan/Desktop/malware/";
		String tempDB = "/Users/dayuyuan/Desktop/malware/DBTest";
		MalwareParser.convertFormat(baseFolderName, tempDB);
	}
}
